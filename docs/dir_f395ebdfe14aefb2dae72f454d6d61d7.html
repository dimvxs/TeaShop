<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Shop ProjectMy Project: frontend/node_modules/immutable Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Shop ProjectMy Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_f395ebdfe14aefb2dae72f454d6d61d7.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">immutable Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Directory dependency graph for immutable:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" loading="lazy" frameborder="0" src="dir_f395ebdfe14aefb2dae72f454d6d61d7_dep.svg" width="138" height="106"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</div>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1717"></a>
Immutable collections for JavaScript</h1>
<p><a href="https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml?query=branch%3Amain"><img src="https://github.com/immutable-js/immutable-js/actions/workflows/ci.yml/badge.svg?branch=main" alt="Build Status" style="pointer-events: none;" class="inline"/></a> <a href="https://immutable-js.slack.com">Chat on slack</a></p>
<p><a href="https://immutable-js.com/docs/">Read the docs</a> and eat your vegetables.</p>
<p>Docs are automatically generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/README.md">README.md</a> and <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts">immutable.d.ts</a>. Please contribute! Also, don't miss the <a href="https://github.com/immutable-js/immutable-js/wiki">wiki</a> which contains articles on additional specific topics. Can't find something? Open an <a href="https://github.com/immutable-js/immutable-js/issues">issue</a>.</p>
<p><b>Table of contents:</b></p>
<ul>
<li>Introduction</li>
<li>Getting started</li>
<li>The case for Immutability</li>
<li>JavaScript-first API</li>
<li>Nested Structures</li>
<li>Equality treats Collections as Values</li>
<li>Batching Mutations</li>
<li>Lazy Seq</li>
<li>Additional Tools and Resources</li>
<li>Contributing</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1718"></a>
Introduction</h1>
<p><a href="https://en.wikipedia.org/wiki/Immutable_object">Immutable</a> data cannot be changed once created, leading to much simpler application development, no defensive copying, and enabling advanced memoization and change detection techniques with simple logic. <a href="https://en.wikipedia.org/wiki/Persistent_data_structure">Persistent</a> data presents a mutative API which does not update the data in-place, but instead always yields new updated data.</p>
<p>Immutable.js provides many Persistent Immutable data structures including: <span class="tt">List</span>, <span class="tt">Stack</span>, <span class="tt">Map</span>, <span class="tt">OrderedMap</span>, <span class="tt">Set</span>, <span class="tt">OrderedSet</span> and <span class="tt">Record</span>.</p>
<p>These data structures are highly efficient on modern JavaScript VMs by using structural sharing via <a href="https://en.wikipedia.org/wiki/Hash_array_mapped_trie">hash maps tries</a> and <a href="https://hypirion.com/musings/understanding-persistent-vector-pt-1">vector tries</a> as popularized by Clojure and Scala, minimizing the need to copy or cache data.</p>
<p>Immutable.js also provides a lazy <span class="tt">Seq</span>, allowing efficient chaining of collection methods like <span class="tt">map</span> and <span class="tt">filter</span> without creating intermediate representations. Create some <span class="tt">Seq</span> with <span class="tt">Range</span> and <span class="tt">Repeat</span>.</p>
<p>Want to hear more? Watch the presentation about Immutable.js:</p>
<p><a href="https://youtu.be/I7IdS-PbEgI"><img src="website/public/Immutable-Data-and-React-YouTube.png" alt="Immutable Data and React" class="inline"/></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1719"></a>
Getting started</h1>
<p>Install <span class="tt">immutable</span> using npm.</p>
<div class="fragment"><div class="line"># using npm</div>
<div class="line">npm install immutable</div>
<div class="line"> </div>
<div class="line"># using Yarn</div>
<div class="line">yarn add immutable</div>
<div class="line"> </div>
<div class="line"># using pnpm</div>
<div class="line">pnpm add immutable</div>
<div class="line"> </div>
<div class="line"># using Bun</div>
<div class="line">bun add immutable</div>
</div><!-- fragment --><p>Then require it into any module.</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const map2 = map1.set(&#39;b&#39;, 50);</div>
<div class="line">map1.get(&#39;b&#39;) + &#39; vs. &#39; + map2.get(&#39;b&#39;); // 2 vs. 50</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1720"></a>
Browser</h2>
<p>Immutable.js has no dependencies, which makes it predictable to include in a Browser.</p>
<p>It's highly recommended to use a module bundler like <a href="https://webpack.js.org/">webpack</a>, <a href="https://rollupjs.org/">rollup</a>, or <a href="https://browserify.org/">browserify</a>. The <span class="tt">immutable</span> npm module works without any additional consideration. All examples throughout the documentation will assume use of this kind of tool.</p>
<p>Alternatively, Immutable.js may be directly included as a script tag. Download or link to a CDN such as <a href="https://cdnjs.com/libraries/immutable">CDNJS</a> or <a href="https://www.jsdelivr.com/package/npm/immutable">jsDelivr</a>.</p>
<p>Use a script tag to directly add <span class="tt">Immutable</span> to the global scope:</p>
<div class="fragment"><div class="line">&lt;script src=&quot;immutable.min.js&quot;&gt;&lt;/script&gt;</div>
<div class="line">&lt;script&gt;</div>
<div class="line">  var map1 = Immutable.Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">  var map2 = map1.set(&#39;b&#39;, 50);</div>
<div class="line">  map1.get(&#39;b&#39;); // 2</div>
<div class="line">  map2.get(&#39;b&#39;); // 50</div>
<div class="line">&lt;/script&gt;</div>
</div><!-- fragment --><p>Or use an AMD-style loader (such as <a href="https://requirejs.org/">RequireJS</a>):</p>
<div class="fragment"><div class="line">require([&#39;./immutable.min.js&#39;], function (Immutable) {</div>
<div class="line">  var map1 = Immutable.Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">  var map2 = map1.set(&#39;b&#39;, 50);</div>
<div class="line">  map1.get(&#39;b&#39;); // 2</div>
<div class="line">  map2.get(&#39;b&#39;); // 50</div>
<div class="line">});</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1721"></a>
Flow &amp; TypeScript</h2>
<p>Use these Immutable collections and sequences as you would use native collections in your <a href="https://flowtype.org/">Flowtype</a> or <a href="https://typescriptlang.org">TypeScript</a> programs while still taking advantage of type generics, error detection, and auto-complete in your IDE.</p>
<p>Installing <span class="tt">immutable</span> via npm brings with it type definitions for Flow (v0.55.0 or higher) and TypeScript (v4.5 or higher), so you shouldn't need to do anything at all!</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1722"></a>
Using TypeScript with Immutable.js v4+</h3>
<p>Immutable.js type definitions embrace ES2015. While Immutable.js itself supports legacy browsers and environments, its type definitions require TypeScript's 2015 lib. Include either <span class="tt">"target": "es2015"</span> or <span class="tt">"lib": "es2015"</span> in your <span class="tt">tsconfig.json</span>, or provide <span class="tt">--target es2015</span> or <span class="tt">--lib es2015</span> to the <span class="tt">tsc</span> command.</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const map2 = map1.set(&#39;b&#39;, 50);</div>
<div class="line">map1.get(&#39;b&#39;) + &#39; vs. &#39; + map2.get(&#39;b&#39;); // 2 vs. 50</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md1723"></a>
Using TypeScript with Immutable.js v3 and earlier:</h3>
<p>Previous versions of Immutable.js include a reference file which you can include via relative path to the type definitions at the top of your file.</p>
<div class="fragment"><div class="line">///&lt;reference path=&#39;./node_modules/immutable/dist/immutable.d.ts&#39;/&gt;</div>
<div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">var map1: Map&lt;string, number&gt;;</div>
<div class="line">map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">var map2 = map1.set(&#39;b&#39;, 50);</div>
<div class="line">map1.get(&#39;b&#39;); // 2</div>
<div class="line">map2.get(&#39;b&#39;); // 50</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md1724"></a>
The case for Immutability</h1>
<p>Much of what makes application development difficult is tracking mutation and maintaining state. Developing with immutable data encourages you to think differently about how data flows through your application.</p>
<p>Subscribing to data events throughout your application creates a huge overhead of book-keeping which can hurt performance, sometimes dramatically, and creates opportunities for areas of your application to get out of sync with each other due to easy to make programmer error. Since immutable data never changes, subscribing to changes throughout the model is a dead-end and new data can only ever be passed from above.</p>
<p>This model of data flow aligns well with the architecture of <a href="https://reactjs.org/">React</a> and especially well with an application designed using the ideas of <a href="https://facebook.github.io/flux/docs/in-depth-overview/">Flux</a>.</p>
<p>When data is passed from above rather than being subscribed to, and you're only interested in doing work when something has changed, you can use equality.</p>
<p>Immutable collections should be treated as <em>values</em> rather than <em>objects</em>. While objects represent some thing which could change over time, a value represents the state of that thing at a particular instance of time. This principle is most important to understanding the appropriate use of immutable data. In order to treat Immutable.js collections as values, it's important to use the <span class="tt">Immutable.is()</span> function or <span class="tt">.equals()</span> method to determine <em>value equality</em> instead of the <span class="tt">===</span> operator which determines object <em>reference identity</em>.</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const map2 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">map1.equals(map2); // true</div>
<div class="line">map1 === map2; // false</div>
</div><!-- fragment --><p>Note: As a performance optimization Immutable.js attempts to return the existing collection when an operation would result in an identical collection, allowing for using <span class="tt">===</span> reference equality to determine if something definitely has not changed. This can be extremely useful when used within a memoization function which would prefer to re-run the function if a deeper equality check could potentially be more costly. The <span class="tt">===</span> equality check is also used internally by <span class="tt">Immutable.is</span> and <span class="tt">.equals()</span> as a performance optimization.</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const map2 = map1.set(&#39;b&#39;, 2); // Set to same value</div>
<div class="line">map1 === map2; // true</div>
</div><!-- fragment --><p>If an object is immutable, it can be "copied" simply by making another reference to it instead of copying the entire object. Because a reference is much smaller than the object itself, this results in memory savings and a potential boost in execution speed for programs which rely on copies (such as an undo-stack).</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const map = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const mapCopy = map; // Look, &quot;copies&quot; are free!</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md1725"></a>
JavaScript-first API</h1>
<p>While Immutable.js is inspired by Clojure, Scala, Haskell and other functional programming environments, it's designed to bring these powerful concepts to JavaScript, and therefore has an Object-Oriented API that closely mirrors that of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla">ES2015</a> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>.</p>
<p>The difference for the immutable collections is that methods which would mutate the collection, like <span class="tt">push</span>, <span class="tt">set</span>, <span class="tt">unshift</span> or <span class="tt">splice</span>, instead return a new immutable collection. Methods which return new arrays, like <span class="tt">slice</span> or <span class="tt">concat</span>, instead return new immutable collections.</p>
<div class="fragment"><div class="line">import { List } from &#39;immutable&#39;;</div>
<div class="line">const list1 = List([1, 2]);</div>
<div class="line">const list2 = list1.push(3, 4, 5);</div>
<div class="line">const list3 = list2.unshift(0);</div>
<div class="line">const list4 = list1.concat(list2, list3);</div>
<div class="line">assert.equal(list1.size, 2);</div>
<div class="line">assert.equal(list2.size, 5);</div>
<div class="line">assert.equal(list3.size, 6);</div>
<div class="line">assert.equal(list4.size, 13);</div>
<div class="line">assert.equal(list4.get(0), 1);</div>
</div><!-- fragment --><p>Almost all of the methods on <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a> will be found in similar form on <span class="tt">Immutable.List</span>, those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> found on <span class="tt">Immutable.Map</span>, and those of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a> found on <span class="tt">Immutable.Set</span>, including collection operations like <span class="tt">forEach()</span> and <span class="tt">map()</span>.</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const alpha = Map({ a: 1, b: 2, c: 3, d: 4 });</div>
<div class="line">alpha.map((v, k) =&gt; k.toUpperCase()).join();</div>
<div class="line">// &#39;A,B,C,D&#39;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1726"></a>
Convert from raw JavaScript objects and arrays.</h2>
<p>Designed to inter-operate with your existing JavaScript, Immutable.js accepts plain JavaScript Arrays and Objects anywhere a method expects a <span class="tt">Collection</span>.</p>
<div class="fragment"><div class="line">import { Map, List } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3, d: 4 });</div>
<div class="line">const map2 = Map({ c: 10, a: 20, t: 30 });</div>
<div class="line">const obj = { d: 100, o: 200, g: 300 };</div>
<div class="line">const map3 = map1.merge(map2, obj);</div>
<div class="line">// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }</div>
<div class="line">const list1 = List([1, 2, 3]);</div>
<div class="line">const list2 = List([4, 5, 6]);</div>
<div class="line">const array = [7, 8, 9];</div>
<div class="line">const list3 = list1.concat(list2, array);</div>
<div class="line">// List [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]</div>
</div><!-- fragment --><p>This is possible because Immutable.js can treat any JavaScript Array or Object as a Collection. You can take advantage of this in order to get sophisticated collection methods on JavaScript Objects, which otherwise have a very sparse native API. Because Seq evaluates lazily and does not cache intermediate results, these operations can be extremely efficient.</p>
<div class="fragment"><div class="line">import { Seq } from &#39;immutable&#39;;</div>
<div class="line">const myObject = { a: 1, b: 2, c: 3 };</div>
<div class="line">Seq(myObject)</div>
<div class="line">  .map((x) =&gt; x * x)</div>
<div class="line">  .toObject();</div>
<div class="line">// { a: 1, b: 4, c: 9 }</div>
</div><!-- fragment --><p>Keep in mind, when using JS objects to construct Immutable Maps, that JavaScript Object properties are always strings, even if written in a quote-less shorthand, while Immutable Maps accept keys of any type.</p>
<div class="fragment"><div class="line">import { fromJS } from &#39;immutable&#39;;</div>
<div class="line"> </div>
<div class="line">const obj = { 1: &#39;one&#39; };</div>
<div class="line">console.log(Object.keys(obj)); // [ &quot;1&quot; ]</div>
<div class="line">console.log(obj[&#39;1&#39;], obj[1]); // &quot;one&quot;, &quot;one&quot;</div>
<div class="line"> </div>
<div class="line">const map = fromJS(obj);</div>
<div class="line">console.log(map.get(&#39;1&#39;), map.get(1)); // &quot;one&quot;, undefined</div>
</div><!-- fragment --><p>Property access for JavaScript Objects first converts the key to a string, but since Immutable Map keys can be of any type the argument to <span class="tt">get()</span> is not altered.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1727"></a>
Converts back to raw JavaScript objects.</h2>
<p>All Immutable.js Collections can be converted to plain JavaScript Arrays and Objects shallowly with <span class="tt">toArray()</span> and <span class="tt">toObject()</span> or deeply with <span class="tt">toJS()</span>. All Immutable Collections also implement <span class="tt">toJSON()</span> allowing them to be passed to <span class="tt">JSON.stringify</span> directly. They also respect the custom <span class="tt">toJSON()</span> methods of nested objects.</p>
<div class="fragment"><div class="line">import { Map, List } from &#39;immutable&#39;;</div>
<div class="line">const deep = Map({ a: 1, b: 2, c: List([3, 4, 5]) });</div>
<div class="line">console.log(deep.toObject()); // { a: 1, b: 2, c: List [ 3, 4, 5 ] }</div>
<div class="line">console.log(deep.toArray()); // [ 1, 2, List [ 3, 4, 5 ] ]</div>
<div class="line">console.log(deep.toJS()); // { a: 1, b: 2, c: [ 3, 4, 5 ] }</div>
<div class="line">JSON.stringify(deep); // &#39;{&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:[3,4,5]}&#39;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1728"></a>
Embraces ES2015</h2>
<p>Immutable.js supports all JavaScript environments, including legacy browsers (even IE11). However it also takes advantage of features added to JavaScript in <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla">ES2015</a>, the latest standard version of JavaScript, including <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">Iterators</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow Functions</a>, <a href="https://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes">Classes</a>, and <a href="https://www.2ality.com/2014/09/es6-modules-final.html">Modules</a>. It's inspired by the native <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a> collections added to ES2015.</p>
<p>All examples in the Documentation are presented in ES2015. To run in all browsers, they need to be translated to ES5.</p>
<div class="fragment"><div class="line">// ES2015</div>
<div class="line">const mapped = foo.map((x) =&gt; x * x);</div>
<div class="line">// ES5</div>
<div class="line">var mapped = foo.map(function (x) {</div>
<div class="line">  return x * x;</div>
<div class="line">});</div>
</div><!-- fragment --><p>All Immutable.js collections are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol">Iterable</a>, which allows them to be used anywhere an Iterable is expected, such as when spreading into an Array.</p>
<div class="fragment"><div class="line">import { List } from &#39;immutable&#39;;</div>
<div class="line">const aList = List([1, 2, 3]);</div>
<div class="line">const anArray = [0, ...aList, 4, 5]; // [ 0, 1, 2, 3, 4, 5 ]</div>
</div><!-- fragment --><p>Note: A Collection is always iterated in the same order, however that order may not always be well defined, as is the case for the <span class="tt">Map</span> and <span class="tt">Set</span>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1729"></a>
Nested Structures</h1>
<p>The collections in Immutable.js are intended to be nested, allowing for deep trees of data, similar to JSON.</p>
<div class="fragment"><div class="line">import { fromJS } from &#39;immutable&#39;;</div>
<div class="line">const nested = fromJS({ a: { b: { c: [3, 4, 5] } } });</div>
<div class="line">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }</div>
</div><!-- fragment --><p>A few power-tools allow for reading and operating on nested data. The most useful are <span class="tt">mergeDeep</span>, <span class="tt">getIn</span>, <span class="tt">setIn</span>, and <span class="tt">updateIn</span>, found on <span class="tt">List</span>, <span class="tt">Map</span> and <span class="tt">OrderedMap</span>.</p>
<div class="fragment"><div class="line">import { fromJS } from &#39;immutable&#39;;</div>
<div class="line">const nested = fromJS({ a: { b: { c: [3, 4, 5] } } });</div>
<div class="line"> </div>
<div class="line">const nested2 = nested.mergeDeep({ a: { b: { d: 6 } } });</div>
<div class="line">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }</div>
<div class="line"> </div>
<div class="line">console.log(nested2.getIn([&#39;a&#39;, &#39;b&#39;, &#39;d&#39;])); // 6</div>
<div class="line"> </div>
<div class="line">const nested3 = nested2.updateIn([&#39;a&#39;, &#39;b&#39;, &#39;d&#39;], (value) =&gt; value + 1);</div>
<div class="line">console.log(nested3);</div>
<div class="line">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }</div>
<div class="line"> </div>
<div class="line">const nested4 = nested3.updateIn([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], (list) =&gt; list.push(6));</div>
<div class="line">// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md1730"></a>
Equality treats Collections as Values</h1>
<p>Immutable.js collections are treated as pure data <em>values</em>. Two immutable collections are considered <em>value equal</em> (via <span class="tt">.equals()</span> or <span class="tt">is()</span>) if they represent the same collection of values. This differs from JavaScript's typical <em>reference equal</em> (via <span class="tt">===</span> or <span class="tt">==</span>) for Objects and Arrays which only determines if two variables represent references to the same object instance.</p>
<p>Consider the example below where two identical <span class="tt">Map</span> instances are not <em>reference equal</em> but are <em>value equal</em>.</p>
<div class="fragment"><div class="line">// First consider:</div>
<div class="line">const obj1 = { a: 1, b: 2, c: 3 };</div>
<div class="line">const obj2 = { a: 1, b: 2, c: 3 };</div>
<div class="line">obj1 !== obj2; // two different instances are always not equal with ===</div>
<div class="line"> </div>
<div class="line">import { Map, is } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const map2 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">map1 !== map2; // two different instances are not reference-equal</div>
<div class="line">map1.equals(map2); // but are value-equal if they have the same values</div>
<div class="line">is(map1, map2); // alternatively can use the is() function</div>
</div><!-- fragment --><p><a class="el" href="class_value.html">Value</a> equality allows Immutable.js collections to be used as keys in Maps or values in Sets, and retrieved with different but equivalent collections:</p>
<div class="fragment"><div class="line">import { Map, Set } from &#39;immutable&#39;;</div>
<div class="line">const map1 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const map2 = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const set = Set().add(map1);</div>
<div class="line">set.has(map2); // true because these are value-equal</div>
</div><!-- fragment --><p>Note: <span class="tt">is()</span> uses the same measure of equality as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a> for scalar strings and numbers, but uses value equality for Immutable collections, determining if both are immutable and all keys and values are equal using the same measure of equality.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1731"></a>
Performance tradeoffs</h3>
<p>While value equality is useful in many circumstances, it has different performance characteristics than reference equality. Understanding these tradeoffs may help you decide which to use in each case, especially when used to memoize some operation.</p>
<p>When comparing two collections, value equality may require considering every item in each collection, on an <span class="tt">O(N)</span> time complexity. For large collections of values, this could become a costly operation. Though if the two are not equal and hardly similar, the inequality is determined very quickly. In contrast, when comparing two collections with reference equality, only the initial references to memory need to be compared which is not based on the size of the collections, which has an <span class="tt">O(1)</span> time complexity. Checking reference equality is always very fast, however just because two collections are not reference-equal does not rule out the possibility that they may be value-equal.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md1732"></a>
Return self on no-op optimization</h3>
<p>When possible, Immutable.js avoids creating new objects for updates where no change in <em>value</em> occurred, to allow for efficient <em>reference equality</em> checking to quickly determine if no change occurred.</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const originalMap = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const updatedMap = originalMap.set(&#39;b&#39;, 2);</div>
<div class="line">updatedMap === originalMap; // No-op .set() returned the original reference.</div>
</div><!-- fragment --><p>However updates which do result in a change will return a new reference. Each of these operations occur independently, so two similar updates will not return the same reference:</p>
<div class="fragment"><div class="line">import { Map } from &#39;immutable&#39;;</div>
<div class="line">const originalMap = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const updatedMap = originalMap.set(&#39;b&#39;, 1000);</div>
<div class="line">// New instance, leaving the original immutable.</div>
<div class="line">updatedMap !== originalMap;</div>
<div class="line">const anotherUpdatedMap = originalMap.set(&#39;b&#39;, 1000);</div>
<div class="line">// Despite both the results of the same operation, each created a new reference.</div>
<div class="line">anotherUpdatedMap !== updatedMap;</div>
<div class="line">// However the two are value equal.</div>
<div class="line">anotherUpdatedMap.equals(updatedMap);</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md1733"></a>
Batching Mutations</h1>
<blockquote class="doxtable">
<p>If a tree falls in the woods, does it make a sound?</p>
<p>If a pure function mutates some local data in order to produce an immutable return value, is that ok?</p>
<p>— Rich Hickey, Clojure </p>
</blockquote>
<p>Applying a mutation to create a new immutable object results in some overhead, which can add up to a minor performance penalty. If you need to apply a series of mutations locally before returning, Immutable.js gives you the ability to create a temporary mutable (transient) copy of a collection and apply a batch of mutations in a performant manner by using <span class="tt">withMutations</span>. In fact, this is exactly how Immutable.js applies complex mutations itself.</p>
<p>As an example, building <span class="tt">list2</span> results in the creation of 1, not 3, new immutable Lists.</p>
<div class="fragment"><div class="line">import { List } from &#39;immutable&#39;;</div>
<div class="line">const list1 = List([1, 2, 3]);</div>
<div class="line">const list2 = list1.withMutations(function (list) {</div>
<div class="line">  list.push(4).push(5).push(6);</div>
<div class="line">});</div>
<div class="line">assert.equal(list1.size, 3);</div>
<div class="line">assert.equal(list2.size, 6);</div>
</div><!-- fragment --><p>Note: Immutable.js also provides <span class="tt">asMutable</span> and <span class="tt">asImmutable</span>, but only encourages their use when <span class="tt">withMutations</span> will not suffice. Use caution to not return a mutable copy, which could result in undesired behavior.</p>
<p><em>Important!</em>: Only a select few methods can be used in <span class="tt">withMutations</span> including <span class="tt">set</span>, <span class="tt">push</span> and <span class="tt">pop</span>. These methods can be applied directly against a persistent data-structure where other methods like <span class="tt">map</span>, <span class="tt">filter</span>, <span class="tt">sort</span>, and <span class="tt">splice</span> will always return new immutable data-structures and never mutate a mutable collection.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1734"></a>
Lazy Seq</h1>
<p><span class="tt">Seq</span> describes a lazy operation, allowing them to efficiently chain use of all the higher-order collection methods (such as <span class="tt">map</span> and <span class="tt">filter</span>) by not creating intermediate collections.</p>
<p><b>Seq is immutable</b> — Once a Seq is created, it cannot be changed, appended to, rearranged or otherwise modified. Instead, any mutative method called on a <span class="tt">Seq</span> will return a new <span class="tt">Seq</span>.</p>
<p><b>Seq is lazy</b> — <span class="tt">Seq</span> does as little work as necessary to respond to any method call. Values are often created during iteration, including implicit iteration when reducing or converting to a concrete data structure such as a <span class="tt">List</span> or JavaScript <span class="tt">Array</span>.</p>
<p>For example, the following performs no work, because the resulting <span class="tt">Seq</span>'s values are never iterated:</p>
<div class="fragment"><div class="line">import { Seq } from &#39;immutable&#39;;</div>
<div class="line">const oddSquares = Seq([1, 2, 3, 4, 5, 6, 7, 8])</div>
<div class="line">  .filter((x) =&gt; x % 2 !== 0)</div>
<div class="line">  .map((x) =&gt; x * x);</div>
</div><!-- fragment --><p>Once the <span class="tt">Seq</span> is used, it performs only the work necessary. In this example, no intermediate arrays are ever created, filter is called three times, and map is only called once:</p>
<div class="fragment"><div class="line">oddSquares.get(1); // 9</div>
</div><!-- fragment --><p>Any collection can be converted to a lazy Seq with <span class="tt">Seq()</span>.</p>
<div class="fragment"><div class="line">import { Map, Seq } from &#39;immutable&#39;;</div>
<div class="line">const map = Map({ a: 1, b: 2, c: 3 });</div>
<div class="line">const lazySeq = Seq(map);</div>
</div><!-- fragment --><p><span class="tt">Seq</span> allows for the efficient chaining of operations, allowing for the expression of logic that can otherwise be very tedious:</p>
<div class="fragment"><div class="line">lazySeq</div>
<div class="line">  .flip()</div>
<div class="line">  .map((key) =&gt; key.toUpperCase())</div>
<div class="line">  .flip();</div>
<div class="line">// Seq { A: 1, B: 2, C: 3 }</div>
</div><!-- fragment --><p>As well as expressing logic that would otherwise seem memory or time limited, for example <span class="tt">Range</span> is a special kind of Lazy sequence.</p>
<div class="fragment"><div class="line">import { Range } from &#39;immutable&#39;;</div>
<div class="line">Range(1, Infinity)</div>
<div class="line">  .skip(1000)</div>
<div class="line">  .map((n) =&gt; -n)</div>
<div class="line">  .filter((n) =&gt; n % 2 === 0)</div>
<div class="line">  .take(2)</div>
<div class="line">  .reduce((r, n) =&gt; r * n, 1);</div>
<div class="line">// 1006008</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md1735"></a>
Comparison of filter(), groupBy(), and partition()</h1>
<p>The <span class="tt">filter()</span>, <span class="tt">groupBy()</span>, and <span class="tt">partition()</span> methods are similar in that they all divide a collection into parts based on applying a function to each element. All three call the predicate or grouping function once for each item in the input collection. All three return zero or more collections of the same type as their input. The returned collections are always distinct from the input (according to <span class="tt">===</span>), even if the contents are identical.</p>
<p>Of these methods, <span class="tt">filter()</span> is the only one that is lazy and the only one which discards items from the input collection. It is the simplest to use, and the fact that it returns exactly one collection makes it easy to combine with other methods to form a pipeline of operations.</p>
<p>The <span class="tt">partition()</span> method is similar to an eager version of <span class="tt">filter()</span>, but it returns two collections; the first contains the items that would have been discarded by <span class="tt">filter()</span>, and the second contains the items that would have been kept. It always returns an array of exactly two collections, which can make it easier to use than <span class="tt">groupBy()</span>. Compared to making two separate calls to <span class="tt">filter()</span>, <span class="tt">partition()</span> makes half as many calls it the predicate passed to it.</p>
<p>The <span class="tt">groupBy()</span> method is a more generalized version of <span class="tt">partition()</span> that can group by an arbitrary function rather than just a predicate. It returns a map with zero or more entries, where the keys are the values returned by the grouping function, and the values are nonempty collections of the corresponding arguments. Although <span class="tt">groupBy()</span> is more powerful than <span class="tt">partition()</span>, it can be harder to use because it is not always possible predict in advance how many entries the returned map will have and what their keys will be.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Summary  </th><th class="markdownTableHeadLeft"><span class="tt">filter</span>  </th><th class="markdownTableHeadLeft"><span class="tt">partition</span>  </th><th class="markdownTableHeadLeft"><span class="tt">groupBy</span>  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">ease of use  </td><td class="markdownTableBodyLeft">easiest  </td><td class="markdownTableBodyLeft">moderate  </td><td class="markdownTableBodyLeft">hardest  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">generality  </td><td class="markdownTableBodyLeft">least  </td><td class="markdownTableBodyLeft">moderate  </td><td class="markdownTableBodyLeft">most  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">laziness  </td><td class="markdownTableBodyLeft">lazy  </td><td class="markdownTableBodyLeft">eager  </td><td class="markdownTableBodyLeft">eager  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft"># of returned sub-collections  </td><td class="markdownTableBodyLeft">1  </td><td class="markdownTableBodyLeft">2  </td><td class="markdownTableBodyLeft">0 or more  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">sub-collections may be empty  </td><td class="markdownTableBodyLeft">yes  </td><td class="markdownTableBodyLeft">yes  </td><td class="markdownTableBodyLeft">no  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">can discard items  </td><td class="markdownTableBodyLeft">yes  </td><td class="markdownTableBodyLeft">no  </td><td class="markdownTableBodyLeft">no  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">wrapping container  </td><td class="markdownTableBodyLeft">none  </td><td class="markdownTableBodyLeft">array  </td><td class="markdownTableBodyLeft">Map/OrderedMap  </td></tr>
</table>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1736"></a>
Additional Tools and Resources</h1>
<ul>
<li><a href="https://github.com/jameshopkins/atom-store/">Atom-store</a><ul>
<li>A Clojure-inspired atom implementation in Javascript with configurability for external persistance.</li>
</ul>
</li>
<li><a href="https://github.com/astorije/chai-immutable">Chai Immutable</a><ul>
<li>If you are using the <a href="https://chaijs.com/">Chai Assertion Library</a>, this provides a set of assertions to use against Immutable.js collections.</li>
</ul>
</li>
<li><a href="https://github.com/fantasyland/fantasy-land">Fantasy-land</a><ul>
<li>Specification for interoperability of common algebraic structures in JavaScript.</li>
</ul>
</li>
<li><a href="https://github.com/pelotom/immutagen">Immutagen</a><ul>
<li>A library for simulating immutable generators in JavaScript.</li>
</ul>
</li>
<li><a href="https://github.com/redbadger/immutable-cursor">Immutable-cursor</a><ul>
<li>Immutable cursors incorporating the Immutable.js interface over Clojure-inspired atom.</li>
</ul>
</li>
<li><a href="https://github.com/DrBoolean/immutable-ext">Immutable-ext</a><ul>
<li>Fantasyland extensions for immutablejs</li>
</ul>
</li>
<li><a href="https://github.com/madeinfree/immutable-js-tools">Immutable-js-tools</a><ul>
<li>Util tools for immutable.js</li>
</ul>
</li>
<li><a href="https://github.com/gajus/redux-immutable">Immutable-Redux</a><ul>
<li>redux-immutable is used to create an equivalent function of Redux combineReducers that works with Immutable.js state.</li>
</ul>
</li>
<li><a href="https://github.com/lukasbuenger/immutable-treeutils">Immutable-Treeutils</a><ul>
<li>Functional tree traversal helpers for ImmutableJS data structures.</li>
</ul>
</li>
<li><a href="https://github.com/ericelliott/irecord">Irecord</a><ul>
<li>An immutable store that exposes an RxJS observable. Great for React.</li>
</ul>
</li>
<li><a href="https://github.com/brianneisler/mudash">Mudash</a><ul>
<li>Lodash wrapper providing Immutable.JS support.</li>
</ul>
</li>
<li><a href="https://github.com/HurricaneJames/react-immutable-proptypes">React-Immutable-PropTypes</a><ul>
<li>PropType validators that work with Immutable.js.</li>
</ul>
</li>
<li><a href="https://github.com/indexiatech/redux-immutablejs">Redux-Immutablejs</a><ul>
<li>Redux Immutable facilities.</li>
</ul>
</li>
<li><a href="https://github.com/yamalight/rxstate">Rxstate</a><ul>
<li>Simple opinionated state management library based on RxJS and Immutable.js.</li>
</ul>
</li>
<li><a href="https://github.com/glenjamin/transit-immutable-js">Transit-Immutable-js</a><ul>
<li>Transit serialisation for Immutable.js.</li>
<li>See also: <a href="https://github.com/cognitect/transit-js">Transit-js</a></li>
</ul>
</li>
</ul>
<p>Have an additional tool designed to work with Immutable.js? Submit a PR to add it to this list in alphabetical order.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1737"></a>
Contributing</h1>
<p>Use <a href="https://github.com/immutable-js/immutable-js/issues">Github issues</a> for requests.</p>
<p>We actively welcome pull requests, learn how to <a href="https://github.com/immutable-js/immutable-js/blob/main/.github/CONTRIBUTING.md">contribute</a>.</p>
<p>Immutable.js is maintained within the <a href="https://www.contributor-covenant.org/version/2/0/code_of_conduct/">Contributor Covenant's Code of Conduct</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1738"></a>
Changelog</h2>
<p>Changes are tracked as <a href="https://github.com/immutable-js/immutable-js/releases">Github releases</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1739"></a>
License</h2>
<p>Immutable.js is <a href="./LICENSE">MIT-licensed</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1740"></a>
Thanks</h2>
<p><a href="https://www.youtube.com/watch?v=K2NYwP90bNs">Phil Bagwell</a>, for his inspiration and research in persistent data structures.</p>
<p><a href="https://github.com/hughfdjackson/">Hugh Jackson</a>, for providing the npm package name. If you're looking for his unsupported package, see <a href="https://github.com/hughfdjackson/immutable">this repository</a>. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_ca0386ec887ae6362f93b0d653b52e0c.html">frontend</a></li><li class="navelem"><a href="dir_8be25e30241834509be35899d7f7509b.html">node_modules</a></li><li class="navelem"><a href="dir_f395ebdfe14aefb2dae72f454d6d61d7.html">immutable</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
